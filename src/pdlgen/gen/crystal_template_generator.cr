require "ecr/macros"
require "../pdl"
require "../fixup"
require "./crystal_util"

module Pdlgen
  module Gen
    # CrystalTemplateGenerator generates Crystal source code using ECR templates.
    class CrystalTemplateGenerator < Emitter
      getter files : Hash(String, String)

      # ECR embedded templates - will be generated at compile time
      ECR.def_to_s "src/pdlgen/gen/crystal_templates/root.ecr"
      ECR.def_to_s "src/pdlgen/gen/crystal_templates/domain_module.ecr"
      ECR.def_to_s "src/pdlgen/gen/crystal_templates/domain_types.ecr"
      ECR.def_to_s "src/pdlgen/gen/crystal_templates/domain_events.ecr"

      def initialize
        @files = Hash(String, String).new
      end

      def self.create(domains : Array(Pdl::Domain), base_pkg : String) : Emitter
        generator = new
        generator.generate(domains, base_pkg)
        generator
      end

      def emit : Hash(String, String)
        @files
      end

      protected def generate(domains : Array(Pdl::Domain), base_pkg : String)
        # Apply fixup first
        Fixup.fix_domains(domains)

        # Generate shared types (circular dependencies)
        generate_shared_types(domains, base_pkg)

        # Generate root package
        generate_root_package(domains, base_pkg)

        # Generate individual domains
        domains.each do |d|
          # Skip deprecated domains
          next if d.deprecated

          # Collect referenced domains for this domain
          referenced_domains = collect_referenced_domains(d, domains)

          # Generate main domain file
          domain_content = render_domain_module(d, domains, base_pkg, referenced_domains)
          pkg_name = CrystalUtil.package_name(d)
          add_file("#{pkg_name}/#{pkg_name}.cr", domain_content)

          # Generate domain types file if there are types
          if !d.types.empty?
            types_content = render_domain_types(d, domains, base_pkg, referenced_domains)
            add_file("#{pkg_name}/types.cr", types_content)
          end

          # Generate domain events file if there are events
          if !d.events.empty?
            events_content = render_domain_events(d, domains, base_pkg, referenced_domains)
            add_file("#{pkg_name}/events.cr", events_content)
          end
        end
      end

      private def generate_shared_types(domains : Array(Pdl::Domain), base_pkg : String)
        # Find circular dependency types
        typs = [] of Pdl::Type
        domains.each do |d|
          d.types.each do |t|
            if t.is_circular_dep
              typs << t
            end
          end
        end

        return if typs.empty?

        content = String.build do |io|
          io << "# Shared Chrome DevTools Protocol Domain types.\n"
          io << "module Cdp\n"
          typs.each do |t|
            generate_type_struct(io, t, nil, domains)
          end
          io << "end\n"
        end

        add_file("cdp/types.cr", content)
      end

      private def generate_root_package(domains : Array(Pdl::Domain), base_pkg : String)
        content = render_root_module(base_pkg)
        add_file("cdp.cr", content)
      end

      private def collect_referenced_domains(d : Pdl::Domain, domains : Array(Pdl::Domain)) : Array(String)
        referenced = Set(String).new

        # Check types
        d.types.each do |t|
          collect_references_from_type(t, d, domains, referenced)
        end

        # Check commands
        d.commands.each do |c|
          c.parameters.each do |p|
            collect_references_from_type(p, d, domains, referenced)
          end
          c.returns.each do |r|
            collect_references_from_type(r, d, domains, referenced)
          end
        end

        # Check events
        d.events.each do |e|
          e.parameters.each do |p|
            collect_references_from_type(p, d, domains, referenced)
          end
        end

        referenced.to_a
      end

      private def collect_references_from_type(t : Pdl::Type, d : Pdl::Domain, domains : Array(Pdl::Domain), referenced : Set(String))
        return if t.ref.empty?

        # Parse ref to get domain
        n = t.ref.split('.', 2)
        ref_domain = n[0]

        # Check if it's a different domain
        if ref_domain != d.domain && domains.any? { |dom| dom.domain == ref_domain }
          referenced << ref_domain.downcase
        end

        # Check array items
        if t.type == Pdl::TypeEnum::Array && t.items
          collect_references_from_type(t.items.not_nil!, d, domains, referenced)
        end
      end

      # Template rendering methods (will be generated by ECR)
      private def render_root_module(base_pkg : String) : String
        # ECR will generate this method
        ""
      end

      private def render_domain_module(d : Pdl::Domain, domains : Array(Pdl::Domain), base_pkg : String, referenced_domains : Array(String)) : String
        # ECR will generate this method
        ""
      end

      private def render_domain_types(d : Pdl::Domain, domains : Array(Pdl::Domain), base_pkg : String, referenced_domains : Array(String)) : String
        # ECR will generate this method
        ""
      end

      private def render_domain_events(d : Pdl::Domain, domains : Array(Pdl::Domain), base_pkg : String, referenced_domains : Array(String)) : String
        # ECR will generate this method
        ""
      end

      # Helper methods for templates
      private def crystal_type(t : Pdl::Type, d : Pdl::Domain, domains : Array(Pdl::Domain)) : String
        CrystalUtil.crystal_type(t, d, domains)
      end

      private def command_type(c : Pdl::Type) : String
        CrystalUtil.command_type(c)
      end

      private def command_returns_type(c : Pdl::Type) : String
        CrystalUtil.command_returns_type(c)
      end

      private def type_name_for_domain(t : Pdl::Type, d : Pdl::Domain?) : String
        name = t.name.camelcase
        return name if d.nil?

        # Remove domain prefix if present
        prefix = d.domain + "."
        if name.starts_with?(prefix)
          name = name[prefix.size..]
        end

        # Also check for lowercase domain (for cross-domain references that got prefixed)
        prefix_lower = d.domain.downcase + "."
        if name.starts_with?(prefix_lower)
          name = name[prefix_lower.size..]
        end

        name
      end

      private def generate_type_struct(io : IO, t : Pdl::Type, d : Pdl::Domain?, domains : Array(Pdl::Domain))
        if t.deprecated
          io << "  @[Deprecated]\n"
        end
        if t.experimental
          io << "  @[Experimental]\n"
        end

        case t.type
        when Pdl::TypeEnum::Object
          if (enum_values = t.enum) && !enum_values.empty?
            # Enum type
            io << "  enum #{type_name_for_domain(t, d)}\n"
            enum_values.each do |value|
              io << "    #{value.camelcase}\n"
            end
            io << "  end\n"
          else
            # Struct type
            io << "  struct #{type_name_for_domain(t, d)}\n"
            io << "    include JSON::Serializable\n\n"
            if t.properties && !t.properties.empty?
              t.properties.each do |p|
                next if p.deprecated && !p.always_emit
                next if p.name.empty?

                type_str = d ? CrystalUtil.crystal_type(p, d, domains) : "JSON::Any"
                io << "    @[JSON::Field(emit_null: false)]\n" if p.optional
                io << "    property #{p.name.underscore} : #{type_str}"
                io << "?" if p.optional
                io << "\n"
              end
            end
            io << "  end\n"
          end
        when Pdl::TypeEnum::String
          io << "  alias #{type_name_for_domain(t, d)} = String\n"
        when Pdl::TypeEnum::Integer
          io << "  alias #{type_name_for_domain(t, d)} = Int64\n"
        when Pdl::TypeEnum::Boolean
          io << "  alias #{type_name_for_domain(t, d)} = Bool\n"
        when Pdl::TypeEnum::Number
          io << "  alias #{type_name_for_domain(t, d)} = Float64\n"
        when Pdl::TypeEnum::Any
          io << "  alias #{type_name_for_domain(t, d)} = JSON::Any\n"
        when Pdl::TypeEnum::Timestamp
          io << "  alias #{type_name_for_domain(t, d)} = Time\n"
        when Pdl::TypeEnum::Binary
          io << "  alias #{type_name_for_domain(t, d)} = String\n"
        else
          io << "  # TODO: Implement type #{t.type} for #{t.name}\n"
          io << "  alias #{type_name_for_domain(t, d)} = JSON::Any\n"
        end
        io << "\n"
      end

      private def add_file(path : String, content : String)
        @files[path] = content
      end
    end
  end
end
