<%# domain_types.ecr - Template for generating domain types %>
<%- # Variables: d (Pdl::Domain), domains (Array(Pdl::Domain)), base_pkg (String), referenced_domains (Array(String)) -%>
require "../cdp"
require "json"
require "time"

<%- referenced_domains.each do |ref_domain| -%>
<%- next if ref_domain == d.domain.downcase -%>
require "../<%= ref_domain %>/<%= ref_domain %>"
<%- end -%>

module <%= base_pkg %>::<%= d.domain.camelcase %>
  <%- d.types.each do |type| -%>
    <%- next if type.is_circular_dep? || type.deprecated? && !type.always_emit? -%>
    <%- if type.deprecated? -%>
  @[Deprecated]
    <%- end -%>
    <%- if type.experimental? -%>
  @[Experimental]
    <%- end -%>
    <%- if type.type == Pdl::TypeEnum::Object -%>
      <%- if (enum_values = type.enum) && !enum_values.empty? -%>
        <%- if type.enum_bit_mask? -%>
  @[Flags]
        <%- end -%>
  enum <%= type_name_for_domain(type, d) %>
        <%- enum_values.each do |value| -%>
    <%= type.enum_value_name_map[value]? || safe_enum_member_name(value) %>
        <%- end -%>
  end
      <%- else -%>
  struct <%= type_name_for_domain(type, d) %>
    include JSON::Serializable
        <%- if type.properties && !type.properties.empty? -%>
          <%- type.properties.each do |prop| -%>
            <%- next if prop.deprecated? && !prop.always_emit? -%>
            <%- next if prop.name.empty? -%>
            <%- type_str = crystal_type(prop, d, domains) -%>
    @[JSON::Field(emit_null: false)]
    <%- if bool_type?(type_str) -%>
    property? <%= prop.name.underscore %> : <%= type_str %><%= "?" if prop.optional? %>
    <%- else -%>
    property <%= prop.name.underscore %> : <%= type_str %><%= "?" if prop.optional? %>
    <%- end -%>
          <%- end -%>
        <%- end -%>
        <%- if d.domain == "DOM" && type_name_for_domain(type, d) == "Node" -%>

    # AttributeValue returns the named attribute for the node.
    def attribute_value(name : String) : String
      value = attribute(name)
      value || ""
    end

    # Attribute returns the named attribute for the node and if it exists.
    def attribute(name : String) : String?
      if attrs = @attributes
        attrs.each_slice(2) do |pair|
          if pair[0] == name
            return pair[1]
          end
        end
      end
      nil
    end
        <%- end -%>
  end
      <%- end -%>
    <%- elsif type.type == Pdl::TypeEnum::String -%>
      <%- if (enum_values = type.enum) && !enum_values.empty? -%>
  alias <%= type_name_for_domain(type, d) %> = String
        <%- enum_values.each do |value| -%>
  <%= type.enum_value_name_map[value]? || string_enum_constant_name(type, value, d) %> = <%= value.inspect %>
        <%- end -%>
      <%- else -%>
  alias <%= type_name_for_domain(type, d) %> = String
      <%- end -%>
    <%- elsif type.type == Pdl::TypeEnum::Integer -%>
      <%- if (enum_values = type.enum) && !enum_values.empty? -%>
        <%- if type.enum_bit_mask? -%>
  @[Flags]
        <%- end -%>
  enum <%= type_name_for_domain(type, d) %> : Int64
        <%- enum_values.each do |value| -%>
    <%= type.enum_value_name_map[value]? || enum_member_name(value) %>
        <%- end -%>
  end
      <%- else -%>
  alias <%= type_name_for_domain(type, d) %> = Int64
      <%- end -%>
    <%- elsif type.type == Pdl::TypeEnum::Boolean -%>
  alias <%= type_name_for_domain(type, d) %> = Bool
    <%- elsif type.type == Pdl::TypeEnum::Number -%>
  alias <%= type_name_for_domain(type, d) %> = Float64
    <%- elsif type.type == Pdl::TypeEnum::Any -%>
  alias <%= type_name_for_domain(type, d) %> = JSON::Any
    <%- elsif type.type == Pdl::TypeEnum::Timestamp -%>
  alias <%= type_name_for_domain(type, d) %> = Time
    <%- elsif type.type == Pdl::TypeEnum::Binary -%>
  alias <%= type_name_for_domain(type, d) %> = String
    <%- else -%>
  # TODO: Implement type <%= type.type %> for <%= type.name %>
  alias <%= type_name_for_domain(type, d) %> = JSON::Any
    <%- end -%>
  <%- if !type.extra.empty? -%>
  <%= type.extra %>
  <%- end -%>

          <%- end -%>
  end
