<%# domain_module.ecr - Template for generating a Crystal domain module with commands %>
<%- # Variables: d (Pdl::Domain), domains (Array(Pdl::Domain)), base_pkg (String), referenced_domains (Array(String)) -%>
require "../cdp"
require "json"
require "time"

<%- referenced_domains.each do |ref_domain| -%>
<%- next if ref_domain == d.domain.downcase -%>
require "../<%= ref_domain %>/<%= ref_domain %>"
<%- end -%>

<%- if !d.types.empty? -%>
require "./types"
<%- end -%>
<%- if !d.events.empty? -%>
require "./events"
<%- end -%>

<%- description_lines = d.description.split('\n') -%>
<%- description_lines.each do |line| -%>
# <%= line.strip %>
<%- end -%>
<%- if d.deprecated -%>
@[Deprecated("This domain is deprecated")]
<%- end -%>
<%- if d.experimental -%>
@[Experimental]
<%- end -%>
module <%= base_pkg %>::<%= d.domain.camelcase %>
  <%- # Generate Result structs first (so they're defined before commands that reference them) -%>
  <%- if !d.commands.empty? -%>
    <%- d.commands.each do |c| -%>
      <%- next if c.deprecated && !c.always_emit -%>
      <%- next if c.returns.empty? -%>
      <%- if c.deprecated -%>
  @[Deprecated]
      <%- end -%>
      <%- if c.experimental -%>
  @[Experimental]
      <%- end -%>
  struct <%= command_returns_type(c) %>
    include JSON::Serializable
    <%- c.returns.each do |r| -%>
      <%- next if r.deprecated && !r.always_emit -%>
      <%- type_str = crystal_type(r, d, domains) -%>
    @[JSON::Field(emit_null: false)]
    <%- if is_bool_type?(type_str) -%>
    property? <%= r.name.underscore %> : <%= type_str %><%= "?" if r.optional %>
    <%- else -%>
    property <%= r.name.underscore %> : <%= type_str %><%= "?" if r.optional %>
    <%- end -%>
    <%- end -%>

    def initialize(<%= c.returns.map { |r| next if r.deprecated && !r.always_emit; "@#{r.name.underscore} : #{crystal_type(r, d, domains)}#{'?' if r.optional}" }.compact.join(", ") %>)
    end
  end

    <%- end -%>
  <%- end -%>

  <%- if !d.commands.empty? -%>
  # Commands
    <%- d.commands.each do |c| -%>
      <%- next if c.deprecated && !c.always_emit -%>
      <%- if c.deprecated -%>
  @[Deprecated]
      <%- end -%>
      <%- if c.experimental -%>
  @[Experimental]
      <%- end -%>
  struct <%= command_type(c) %>
    include JSON::Serializable
    include <%= base_pkg %>::Request
    <%- c.parameters.each do |p| -%>
      <%- next if p.deprecated && !p.always_emit -%>
      <%- next if p.name.empty? -%>
      <%- type_str = crystal_type(p, d, domains) -%>
    @[JSON::Field(emit_null: false)]
    <%- if is_bool_type?(type_str) -%>
    property? <%= p.name.underscore %> : <%= type_str %><%= "?" if p.optional %>
    <%- else -%>
    property <%= p.name.underscore %> : <%= type_str %><%= "?" if p.optional %>
    <%- end -%>
    <%- end -%>

    def initialize(<%= c.parameters.map { |p| next if p.deprecated && !p.always_emit; next if p.name.empty?; "@#{p.name.underscore} : #{crystal_type(p, d, domains)}#{'?' if p.optional}" }.compact.join(", ") %>)
    end

    # ProtoReq returns the protocol method name.
    def proto_req : String
      "<%= d.domain %>.<%= c.name %>"
    end

    <%- if !c.returns.empty? -%>
    # Call sends the request and returns the result.
    def call(c : <%= base_pkg %>::Client) : <%= command_returns_type(c) %>
      res = <%= command_returns_type(c) %>.new
      <%= base_pkg %>.call(proto_req, self, res, c)
      res
    end
    <%- else -%>
    # Call sends the request.
    def call(c : <%= base_pkg %>::Client) : Nil
      <%= base_pkg %>.call(proto_req, self, nil, c)
    end
    <%- end -%>
  end

    <%- end -%>
  <%- end -%>
end
